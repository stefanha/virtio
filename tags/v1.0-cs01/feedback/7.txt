Document: virtio-v1.0-csprd01
Number: 7
Date: Wed, 29 Jan 2014 17:05:06 -0800
Link to Mail: https://lists.oasis-open.org/archives/virtio-comment/201401/msg00058.html
Commenter name: Arun Subbarao <asubbarao@lnxw.com>
Decision: 2014-02-11 minutes: Applied

(PARTIAL: there is more feedback)

The lack of any kind of distinguishing emphasis used consistently with field names in this document makes it hard to read. For example, here, is it literally the next field or the field called "next"? Because there is a field called "next" defined by this spec. This made me scroll back to the used ring definition to refresh the meaning of field "next" in my head, only to realize there is no such field in that particular structure. You are not kind to the reader.

If you search for the field name "avail_event", you will see that sometimes it is emphasized with quotes and sometimes it isn't. Probably better to use a monospace font instead.

Proposal:

Use \field{} for all register and field names.

This currently just makes it italic.  Generally this means changing
phrases of form "the XXX field" to "\field{XXX}", but other minor
consistency and formatting changes were made along the way:

1) Device Status became "device status" to match other fields.

2) PCI: The legacy PCI fields now have the same name as modern ones (where
   appropriate) so the general text still stands.

3) PCI: the msix_config field is renamed config_msix_vector to match the
   queue equivalent.

4) MMIO: use italics for field names in table instead of bold (to match
   the rest of the document)

5) MMIO: extra spacing in "QueueDescLow/ QueueDescHigh" and "QueueUsedLow/
   QueueUsedHigh" removed.

6) NET: CAN changed to MAY (was: 'a transitional device CAN defer MAC
   update, or CAN defer')

7) SCSI: control commands are now an item list, for better formatting.

8) SCSI: events now an item list.  reason fields now a description list.

9) VIRTIO_F_RING_EVENT_IDX is now a coherent sentence instead of just
   ending "; the flags field is used". 

Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/commands.tex b/commands.tex
index 1f6fad2..671757b 100644
--- a/commands.tex
+++ b/commands.tex
@@ -5,3 +5,6 @@
 \definecolor{oasis1}{RGB}{85,38,129}
 \definecolor{oasis2}{RGB}{227,175,27}
 \definecolor{shadecolor}{RGB}{230,230,230}
+
+% How we format a field name
+\newcommand{\field}[1]{\emph{#1}}
diff --git a/content.tex b/content.tex
index 27a957d..2adc393 100644
--- a/content.tex
+++ b/content.tex
@@ -6,21 +6,21 @@ A virtio device is discovered and identified by a bus-specific method
 device consists of the following parts:
 
 \begin{itemize}
-\item Device Status field
+\item Device status field
 \item Feature bits
 \item Configuration space
 \item One or more virtqueues
 \end{itemize}
 
-\section{Device Status Field}\label{sec:Basic Facilities of a Virtio Device / Device Status Field}
+\section{\field{Device Status} Field}\label{sec:Basic Facilities of a Virtio Device / Device Status Field}
 
-The driver MUST update the Device Status field in the order below to
+The driver MUST update the \field{device status} field in the order below to
 indicate its progress. This provides a simple low-level diagnostic:
 it's most useful to imagine them hooked up to traffic lights on the
 console indicating the status of each device.  The driver MUST NOT
-clear a device status bit.
+clear a \field{device status} bit.
 
-This field is 0 upon reset, otherwise at least one bit should be set:
+\field{device status} is 0 upon reset, otherwise at least one bit should be set:
 
 \begin{description}
 \item[ACKNOWLEDGE (1)] Indicates that the guest OS has found the
@@ -332,8 +332,8 @@ VIRTIO_F_ANY_LAYOUT feature is accepted.
 \subsection{The Virtqueue Descriptor Table}\label{sec:Basic Facilities of a Virtio Device / Virtqueues / The Virtqueue Descriptor Table}
 
 The descriptor table refers to the buffers the driver is using for
-the device. The addresses are physical addresses, and the buffers
-can be chained via the next field. Each descriptor describes a
+the device. \field{addr} is a physical address, and the buffers
+can be chained via \field{next}. Each descriptor describes a
 buffer which is read-only for the device (``device-readable'') or write-only for the device (``device-writable''), but a chain of
 descriptors can contain both device-readable and device-writable buffers.
 A device MUST NOT write to a device-readable buffer, and a device SHOULD NOT
@@ -378,8 +378,8 @@ Some devices benefit by concurrently dispatching a large number
 of large requests. The VIRTIO_RING_F_INDIRECT_DESC feature allows this (see \ref{sec:virtio-ring.h}~\nameref{sec:virtio-ring.h}). To increase
 ring capacity the driver can store a table of indirect
 descriptors anywhere in memory, and insert a descriptor in main
-virtqueue (with flags\&VRING_DESC_F_INDIRECT on) that refers to memory buffer
-containing this indirect descriptor table; fields addr and len
+virtqueue (with \field{flags}\&VRING_DESC_F_INDIRECT on) that refers to memory buffer
+containing this indirect descriptor table; \field{addr} and \field{len}
 refer to the indirect table address and length in bytes,
 respectively.
 
@@ -387,7 +387,7 @@ The driver MUST NOT set the VRING_DESC_F_INDIRECT flag unless the
 VIRTIO_RING_F_INDIRECT_DESC feature was negotiated.
 
 The indirect table layout structure looks like this
-(len is the length of the descriptor that refers to this table,
+(\field{len} is the length of the descriptor that refers to this table,
 which is a variable, so this code won't compile):
 
 \begin{lstlisting}
@@ -399,13 +399,13 @@ struct indirect_descriptor_table {
 
 The first indirect descriptor is located at start of the indirect
 descriptor table (index 0), additional indirect descriptors are
-chained by next field. An indirect descriptor without next field
-(with flags\&VRING_DESC_F_NEXT off) signals the end of the descriptor.
+chained by \field{next}. An indirect descriptor without a valid \field{next}
+(with \field{flags}\&VRING_DESC_F_NEXT off) signals the end of the descriptor.
 An
 indirect descriptor can not refer to another indirect descriptor
-table (flags\&VRING_DESC_F_INDIRECT MUST be off). A single indirect descriptor
+table (\field{flags}\&VRING_DESC_F_INDIRECT MUST be off). A single indirect descriptor
 table can include both device-readable and device-writable descriptors;
-the device MUST ignore the write-only flag (flags\&VRING_DESC_F_WRITE) in the descriptor that refers to it.
+the device MUST ignore the write-only flag (\field{flags}\&VRING_DESC_F_WRITE) in the descriptor that refers to it.
 
 \subsection{The Virtqueue Available Ring}\label{sec:Basic Facilities of a Virtio Device / Virtqueues / The Virtqueue Available Ring}
 
@@ -424,21 +424,21 @@ The driver uses the available ring to offer buffers to the
 device: each ring entry refers to the head of a descriptor chain.  It is only
 written by the driver and read by the device.
 
-The “idx” field indicates where the driver would put the next descriptor
+\field{idx} field indicates where the driver would put the next descriptor
 entry in the ring (modulo the queue size). This starts at 0, and increases.
 
-If the VIRTIO_RING_F_EVENT_IDX feature bit is not negotiated, the
-“flags” field offers a crude interrupt control mechanism.  The driver
+If the VIRTIO_RING_F_EVENT_IDX feature bit is not negotiated,
+\field{flags} field offers a crude interrupt control mechanism.  The driver
 MUST set this to 0 or 1: 1 indicates that the device SHOULD NOT send
 an interrupt when it consumes a descriptor chain from the available
-ring.  The device MUST ignore the used_event value in this case.
+ring.  The device MUST ignore the \field{used_event} value in this case.
 
 Otherwise, if the VIRTIO_RING_F_EVENT_IDX feature bit is negotiated,
-the driver MUST set the "flags" field to 0, and use the “used_event”
-field in the used ring instead.  The driver can ask the device to delay interrupts
-until an entry with an index specified by the “used_event” field is
-written in the used ring (equivalently, until the idx field in the
-used ring will reach the value used_event + 1).
+the driver MUST set \field{flags} to 0, and use \field{used_event}
+in the used ring instead.  The driver can ask the device to delay interrupts
+until an entry with an index specified by \field{used_event} is
+written in the used ring (equivalently, until \field{idx} in the
+used ring will reach the value \field{used_event} + 1).
 
 The driver MUST handle spurious interrupts: either form of interrupt
 suppression is merely an optimization; it may not suppress interrupts
@@ -469,27 +469,27 @@ struct vring_used_elem {
 The used ring is where the device returns buffers once it is done with
 them: it is only written to by the device, and read by the driver.
 
-Each entry in the ring is a pair: the head entry of the
+Each entry in the ring is a pair: \field{id} indicates the head entry of the
 descriptor chain describing the buffer (this matches an entry
-placed in the available ring by the guest earlier), and the total
+placed in the available ring by the guest earlier), and \field{len} the total
 of bytes written into the buffer. The latter is extremely useful
 for drivers using untrusted buffers: if you do not know exactly
 how much has been written by the device, you usually have to zero
 the buffer to ensure no data leakage occurs.
 
-If the VIRTIO_RING_F_EVENT_IDX feature bit is not negotiated, the
-“flags” field offers a crude interrupt control mechanism.  The driver
+If the VIRTIO_RING_F_EVENT_IDX feature bit is not negotiated,
+\field{flags} offers a crude interrupt control mechanism.  The driver
 MUST initialize this to 0, the device MUST set this to 0 or 1: 1
 indicates that the driver SHOULD NOT send an notification when it adds
 a descriptor chain to the available ring.  The driver MUST ignore the
-used_event value in this case.
+\field{used_event} value in this case.
 
 Otherwise, if the VIRTIO_RING_F_EVENT_IDX feature bit is negotiated,
-the device MUST leave the "flags" field at 0, and use the
-“avail_event” field in the used ring instead.  The device can ask the
+the device MUST leave \field{flags} at 0, and use
+\field{avail_event} in the used ring instead.  The device can ask the
 driver to delay notifications until an entry with an index specified
-by the “avail_event” field is written in the available ring (equivalently,
-until the idx field in the used ring will reach the value avail_event +
+by \field{avail_event} is written in the available ring (equivalently,
+until \field{idx} in the used ring will reach the value \field{avail_event} +
 1).
 
 The device MUST handle spurious notification: either form of
@@ -533,7 +533,7 @@ The driver MUST follow this sequence to initialize a device:
 \item\label{itm:General Initialization And Device Operation / Device Initialization / Set FEATURES-OK} Set the FEATURES_OK status bit.  The driver MUST not accept
    new feature bits after this step.
 
-\item\label{itm:General Initialization And Device Operation / Device Initialization / Re-read FEATURES-OK} Re-read the status byte to ensure the FEATURES_OK bit is still
+\item\label{itm:General Initialization And Device Operation / Device Initialization / Re-read FEATURES-OK} Re-read \field{device status} to ensure the FEATURES_OK bit is still
    set: otherwise, the device does not support our subset of features
    and the device is unusable.
 
@@ -601,11 +601,11 @@ The driver offers buffers to one of the device's virtqueues as follows:
   the updated descriptor table and available ring before the next
   step.
 
-\item The available “idx” field is increased by the number of
+\item The available \field{idx} is increased by the number of
   descriptor chain heads added to the available ring.
 
 \item The driver MUST perform a suitable memory barrier to ensure that it updates
-  the "idx" field before checking for notification suppression.
+  the \field{idx} field before checking for notification suppression.
 
 \item If notifications are not suppressed, the driver MUST notify the device
     of the new available buffers.
@@ -617,7 +617,7 @@ the ring buffer is the same size as the descriptor table, so step
 (1) will prevent such a condition.
 
 In addition, the maximum queue size is 32768 (it must be a power
-of 2 which fits in 16 bits), so the 16-bit “idx” value can always
+of 2 which fits in 16 bits), so the 16-bit \field{idx} value can always
 distinguish between a full and empty buffer.
 
 Here is a description of each stage in more detail.
@@ -634,19 +634,19 @@ for each buffer element, b:
 
 \begin{enumerate}
 \item Get the next free descriptor table entry, d
-\item Set d.addr to the physical address of the start of b
-\item Set d.len to the length of b.
-\item If b is device-writable, set d.flags to VRING_DESC_F_WRITE,
+\item Set \field{d.addr} to the physical address of the start of b
+\item Set \field{d.len} to the length of b.
+\item If b is device-writable, set \field{d.flags} to VRING_DESC_F_WRITE,
     otherwise 0.
 \item If there is a buffer element after this:
     \begin{enumerate}
-    \item Set d.next to the index of the next free descriptor
+    \item Set \field{d.next} to the index of the next free descriptor
       element.
-    \item Set the VRING_DESC_F_NEXT bit in d.flags.
+    \item Set the VRING_DESC_F_NEXT bit in \field{d.flags}.
     \end{enumerate}
 \end{enumerate}
 
-In practice, the d.next fields are usually used to chain free
+In practice, \field{d.next} is usually used to chain free
 descriptors, and a separate count kept to check there are enough
 free descriptors before beginning the mappings.
 
@@ -662,22 +662,22 @@ avail->ring[avail->idx % qsz] = head;
 \end{lstlisting}
 
 However, in general the driver can add many descriptor chains before it updates
-the “idx” field (at which point they become visible to the
+\field{idx} (at which point they become visible to the
 device), so it is common to keep a counter of how many the driver has added:
 
 \begin{lstlisting}
 avail->ring[(avail->idx + added++) % qsz] = head;
 \end{lstlisting}
 
-\subsubsection{Updating The Index Field}\label{sec:General Initialization And Device Operation / Device Operation / Supplying Buffers to The Device / Updating The Index Field}
+\subsubsection{Updating \field{idx}}\label{sec:General Initialization And Device Operation / Device Operation / Supplying Buffers to The Device / Updating idx}
 
-Once the index field of the virtqueue is updated, the device will
+Once \field{idx} is updated, the device will
 be able to access the descriptor chains the driver created and the
 memory they refer to. This is why a memory barrier is generally
-used before the index update, to ensure it sees the most up-to-date
+used before the \field{idx} update, to ensure it sees the most up-to-date
 copy.
 
-The index field always increments, and the driver can let it wrap naturally at
+\field{idx} always increments, and the driver can let it wrap naturally at
 65536:
 
 \begin{lstlisting}
@@ -688,20 +688,20 @@ avail->idx += added;
 
 The actual method of device notification is bus-specific, but generally
 it can be expensive.  So the device MAY suppress such notifications if it
-doesn't need them.  The driver has to be careful to expose the new index
+doesn't need them.  The driver has to be careful to expose the new \field{idx}
 value before checking if notifications are suppressed: the driver MAY notify
 gratuitously, but MUST NOT to omit a required notification. So again,
-the driver SHOULD use a memory barrier here before reading the flags or the
-avail_event field.
+the driver SHOULD use a memory barrier here before reading \field{flags} or
+\field{avail_event}.
 
 If the VIRTIO_F_RING_EVENT_IDX feature is not negotiated, and if the
 VRING_USED_F_NOTIFY flag is not set, the driver SHOULD notify the
 device.
 
-If the VIRTIO_F_RING_EVENT_IDX feature is negotiated, the driver reads the
-avail_event field in the available ring structure. If the
-available index crossed_the avail_event field value since the
-last notification, the driver SHOULD notify the device.  The avail_event field wraps naturally at 65536 as well,
+If the VIRTIO_F_RING_EVENT_IDX feature is negotiated, the driver reads
+\field{avail_event} in the available ring structure. If the
+available \field{idx} crossed \field{avail_event} value since the
+last notification, the driver SHOULD notify the device.  \field{avail_event} wraps naturally at 65536 as well,
 giving the following algorithm for calculating whether a device needs
 notification:
 
@@ -718,21 +718,21 @@ similar to the algorithm used for the driver to send the device a
 buffer:
 
 \begin{enumerate}
-\item Write the head descriptor number to the next field in the used
+\item Write the head descriptor number to the next entry in the used
   ring.
 
-\item Update the used ring index.
+\item Update the used ring \field{idx}.
 
 \item Deliver an interrupt if necessary:
 
   \begin{enumerate}
   \item If the VIRTIO_F_RING_EVENT_IDX feature is not negotiated:
     check if the VRING_AVAIL_F_NO_INTERRUPT flag is not set in
-    avail->flags.
+    \field{flags} in the available structure.
 
   \item If the VIRTIO_F_RING_EVENT_IDX feature is negotiated: check
-    whether the used index crossed the used_event field value
-    since the last update. The used_event field wraps naturally
+    whether the used \field{idx} crossed the \field{used_event} value
+    since the last update. \field{used_event} wraps naturally
     at 65536 as well:
 \begin{lstlisting}
 (u16)(new_idx - used_event - 1) < (u16)(new_idx - old_idx)
@@ -741,10 +741,10 @@ buffer:
 \end{enumerate}
 
 For each ring, the driver MAY then disable interrupts by writing
-VRING_AVAIL_F_NO_INTERRUPT flag in avail structure, if required.
+VRING_AVAIL_F_NO_INTERRUPT to \field{flags} in available structure, if required.
 Once it has processed the ring entries, it SHOULD re-enable
-interrupts by clearing the VRING_AVAIL_F_NO_INTERRUPT flag or updating the
-EVENT_IDX field in the available structure.  The driver SHOULD then
+interrupts by clearing VRING_AVAIL_F_NO_INTERRUPT in \field{flags} or updating
+\field{event_idx} in the available structure.  The driver SHOULD then
 execute a memory barrier, and then recheck the ring empty
 condition. This is necessary to handle the case where after the
 last check and before enabling interrupts, an interrupt has been
@@ -783,7 +783,7 @@ A driver MUST NOT alter descriptor table entries which have been
 exposed in the available ring (and not marked consumed by the device
 in the used ring) of a live virtqueue.
 
-A driver MUST NOT decrement the available index on a live virtqueue (ie.
+A driver MUST NOT decrement the available \field{idx} on a live virtqueue (ie.
 there is no way to "unexpose" buffers).
 
 Thus a driver MUST ensure a virtqueue isn't live (by device reset) before removing exposed buffers.
@@ -854,25 +854,25 @@ struct virtio_pci_cap {
 \end{lstlisting}
 
 This structure can be followed by extra data, depending on
-cfg_type, as documented below.  The device MAY append extra data
-or padding to any structure beyond that, the device MUST accept a cap_len field
+\field{cfg_type}, as documented below.  The device MAY append extra data
+or padding to any structure beyond that, the device MUST accept a \field{cap_len} value
 which is larger than specified here.
 
 The fields are interpreted as follows:
 
 \begin{description}
-\item[cap_vndr]
+\item[\field{cap_vndr}]
         0x09; Identifies a vendor-specific capability.
 
-\item[cap_next]
+\item[\field{cap_next}]
         Link to next capability in the capability list in the configuration space.
 
-\item[cap_len]
+\item[\field{cap_len}]
         Length of this capability structure, including the whole of
         struct virtio_pci_cap, and extra data if any.
         This length MAY include padding, or fields unused by the driver.
 
-\item[cfg_type]
+\item[\field{cfg_type}]
         identifies the structure, according to the following table:
 
 \begin{lstlisting}
@@ -890,7 +890,7 @@ The fields are interpreted as follows:
 
         Any other value - reserved for future use. Drivers MUST
         ignore any vendor-specific capability structure which has
-        a reserved cfg_type value.
+        a reserved \field{cfg_type} value.
 
         The device MAY offer more than one structure of any type - this makes it
         possible for the device to expose multiple interfaces to drivers.  The order of
@@ -898,14 +898,14 @@ The fields are interpreted as follows:
         suggested by the device; drivers SHOULD use the first interface that they can
         support.  For example, on some hypervisors, notifications using IO accesses are
         faster than memory accesses. In this case, the device would expose two
-        capabilities with cfg_type set to VIRTIO_PCI_CAP_NOTIFY_CFG:
+        capabilities with \field{cfg_type} set to VIRTIO_PCI_CAP_NOTIFY_CFG:
         the first one addressing an I/O BAR, the second one addressing a memory BAR.
         In this example, the driver SHOULD use the I/O BAR if I/O resources are available, and fall back on
         memory BAR when I/O resources are unavailable.
 
         Each structure is detailed individually below.
 
-\item[bar]
+\item[\field{bar}]
         values 0x0 to 0x5 specify a Base Address register (BAR) belonging to
         the function located beginning at 10h in Configuration Space
         and used to map the structure into Memory or I/O Space.
@@ -914,21 +914,21 @@ The fields are interpreted as follows:
 
         Any other value is reserved for future use. Drivers MUST
         ignore any vendor-specific capability structure which has
-        a reserved bar value.
+        a reserved \field{bar} value.
 
-\item[offset]
+\item[\field{offset}]
         indicates where the structure begins relative to the base address associated
         with the BAR.
 
-\item[length]
+\item[\field{length}]
         indicates the length of the structure.
 
-        length MAY include padding, or fields unused by the driver, or
+        \field{length} MAY include padding, or fields unused by the driver, or
         future extensions.
 
         Drivers SHOULD only map part of configuration structure
         large enough for device operation.  Drivers MUST handle
-        unexpectedly large length fields, but MAY check that length
+        an unexpectedly large \field{length}, but MAY check that \field{length}
         is large enough for device operation.
 
         For example, a future device might present a large structure size of several
@@ -941,7 +941,7 @@ The fields are interpreted as follows:
 
 \subsubsection{Common configuration structure layout}\label{sec:Virtio Transport Options / Virtio Over PCI Bus / PCI Device Layout / Common configuration structure layout}
 
-The common configuration structure is found at the bar and offset within the VIRTIO_PCI_CAP_COMMON_CFG capability; its layout is below.
+The common configuration structure is found at the \field{bar} and \field{offset} within the VIRTIO_PCI_CAP_COMMON_CFG capability; its layout is below.
 
 The device MUST present at least one common configuration capability.
 
@@ -970,76 +970,76 @@ struct virtio_pci_common_cfg {
 \end{lstlisting}
 
 \begin{description}
-\item[device_feature_select]
-        The driver uses this to select which feature bits the device_feature field shows.
+\item[\field{device_feature_select}]
+        The driver uses this to select which feature bits \field{device_feature} shows.
         Value 0x0 selects Feature Bits 0 to 31, 0x1 selects Feature Bits 32 to 63.
-        The device MUST present 0 on device_feature for any other value, but the driver MUST NOT rely on this.
+        The device MUST present 0 on \field{device_feature} for any other value, but the driver MUST NOT rely on this.
 
-\item[device_feature]
+\item[\field{device_feature}]
         The device uses this to report which feature bits it is
         offering to the driver: the driver writes to
-        device_feature_select to select which are presented.
+        \field{device_feature_select} to select which are presented.
 
-\item[driver_feature_select]
-        The driver uses this to select which feature bits the driver_feature field shows.
+\item[\field{driver_feature_select}]
+        The driver uses this to select which feature bits \field{driver_feature} shows.
         Value 0x0 selects Feature Bits 0 to 31, 0x1 selects Feature Bits 32 to 63.
-        When set to any other value, the device MUST return 0 on reads from driver_feature
-        return 0, and ignore writing of 0 into driver_feature.  The driver
-        MUST not write any other value into driver_feature (a corollary of
+        When set to any other value, the device MUST return 0 on reads from \field{driver_feature}
+        return 0, and ignore writing of 0 into \field{driver_feature}.  The driver
+        MUST not write any other value into \field{driver_feature} (a corollary of
         the rule that the driver can only write a subset of device features).
 
-\item[driver_feature]
+\item[\field{driver_feature}]
         The driver writes this to accept feature bits offered by the device.
-        Driver Feature Bits selected by driver_feature_select.
+        Driver Feature Bits selected by \field{driver_feature_select}.
 
-\item[msix_config]
+\item[\field{config_msix_vector}]
         The driver sets the Configuration Vector for MSI-X.
 
-\item[num_queues]
+\item[\field{num_queues}]
         The device specifies the maximum number of virtqueues supported here.
 
-\item[device_status]
-        The driver writes the Device Status here. Writing 0 into this
+\item[\field{device_status}]
+        The driver writes the device status here (see \ref{sec:Basic Facilities of a Virtio Device / Device Status Field}). Writing 0 into this
         field resets the device.
 
-\item[config_generation]
+\item[\field{config_generation}]
         Configuration atomicity value.  The device changes this every time the
         configuration noticeably changes.  This means the device may
         only change the value after a configuration read operation,
         but MUST change it if there is any risk of a driver seeing an
         inconsistent configuration state.
 
-\item[queue_select]
+\item[\field{queue_select}]
         Queue Select. The driver selects which virtqueue the following
         fields refer to.
 
-\item[queue_size]
+\item[\field{queue_size}]
         Queue Size.  On reset, specifies the maximum queue size supported by
         the hypervisor. This can be modified by driver to reduce memory requirements.
         The device MUST set this to 0 if this virtqueue is unavailable.
 
-\item[queue_msix_vector]
-        The driver uses this to specify the Queue Vector for MSI-X.
+\item[\field{queue_msix_vector}]
+        The driver uses this to specify the queue vector for MSI-X.
 
-\item[queue_enable]
+\item[\field{queue_enable}]
         The driver uses this to selectively prevent the device from executing requests from this virtqueue.
         1 - enabled; 0 - disabled.
 
         The driver MUST configure the other virtqueue fields before enabling
         the virtqueue.
 
-\item[queue_notify_off]
+\item[\field{queue_notify_off}]
         The driver reads this to calculate the offset from start of Notification structure at
         which this virtqueue is located.
         Note: this is *not* an offset in bytes. See \ref{sec:Virtio Transport Options / Virtio Over PCI Bus / PCI Device Layout / Notification capability} below.
 
-\item[queue_desc]
+\item[\field{queue_desc}]
         The driver writes the physical address of Descriptor Table here.
 
-\item[queue_avail]
+\item[\field{queue_avail}]
         The driver writes the physical address of Available Ring here.
 
-\item[queue_used]
+\item[\field{queue_used}]
         The driver writes the physical address of Used Ring here.
 \end{description}
 
@@ -1058,24 +1058,24 @@ struct virtio_pci_notify_cap {
 };
 \end{lstlisting}
 
-The device MUST present an even cap.length of at least 2.
+The device MUST present an even \field{cap.length} of at least 2.
 
-The device MUST present notify_off_multiplier as an even power of 2,
-or 0.  The device MUST ignore a capability with notify_off_multiplier
+The device MUST present \field{notify_off_multiplier} as an even power of 2,
+or 0.  The device MUST ignore a capability with \field{notify_off_multiplier}
 of 1.
 
-notify_off_multiplier field is combined with the queue_notify_off to
+\field{notify_off_multiplier} is combined with the \field{queue_notify_off} to
 derive the Queue Notify address within a BAR for a specific queue:
 
 \begin{lstlisting}
         cap.offset + queue_notify_off * notify_off_multiplier
 \end{lstlisting}
 
-The BAR, offset and notify_off_multiplier are taken from the
-notification capability structure above, and the queue_notify_off is
+The \field{bar}, \field{offset} and \field{notify_off_multiplier} are taken from the
+notification capability structure above, and the \field{queue_notify_off} is
 taken from the common configuration structure.
 
-For example, if notifier_off_multiplier is 0, all queues will use the same 
+For example, if \field{notifier_off_multiplier} is 0, all queues will use the same 
 Queue Notify address.
 
 \subsubsection{ISR status capability}\label{sec:Virtio Transport Options / Virtio Over PCI Bus / PCI Device Layout / ISR status capability}
@@ -1107,23 +1107,23 @@ To access a device region, the driver writes into the capability
 structure (ie. within the PCI configuration space) as follows:
 
 \begin{itemize}
-\item The driver sets the BAR to access by writing to the cap.bar field.
+\item The driver sets the BAR to access by writing to \field{cap.bar}.
 
 \item The driver sets the size of the access by writing 1, 2 or 4 to
-  the cap.length field.
+  \field{cap.length}.
 
-\item The driver sets the offset within the BAR by writing to the
-  cap.offset field.  The driver MUST NOT write an offset which is not
-  a multiple of cap.length (ie. all accesses must be aligned).
+\item The driver sets the offset within the BAR by writing to
+  \field{cap.offset}.  The driver MUST NOT write an offset which is not
+  a multiple of \field{cap.length} (ie. all accesses must be aligned).
 \end{itemize}
 
 At that point, the pci_cfg_data field will provide a window of size
-cap.length into the given cap.bar at offset cap.offset: writes will
+\field{cap.length} into the given \field{cap.bar} at offset \field{cap.offset}: writes will
 have the same effect as writes into the BAR, and reads will have the
 same effect and return the same value as reads from the BAR.
 
 The driver MUST perform reads/writes from/to pci_cfg_data of the same
-width as given by cap.length.
+width as given by \field{cap.length}.
 
 \subsubsection{Legacy Interfaces: A Note on PCI Device Layout}\label{sec:Virtio Transport Options / Virtio Over PCI Bus / PCI Device Layout / Legacy Interfaces: A Note on PCI Device Layout}
 
@@ -1152,7 +1152,7 @@ When used through the legacy interface, the virtio header looks as follows:
  Read / Write & R & R+W & R+W & R & R+W & R+W & R+W & R \\
 \hline
  Purpose & Device Features bits 0:31 & Driver Features bits 0:31 &
-  Queue Address & Queue Size & Queue Select & Queue Notify &
+  Queue Address & \field{queue_size} & \field{queue_select} & Queue Notify &
   Device Status & ISR \newline Status \\
 \hline
 \end{tabularx}
@@ -1166,7 +1166,7 @@ Bits       & 16             & 16     \\
 \hline
 Read/Write & R+W            & R+W    \\
 \hline
-Purpose (MSI-X) & Configuration Vector  & Queue Vector \\
+Purpose (MSI-X) & \field{config_msix_vector}  & \field{queue_msix_vector} \\
 \hline
 \end{tabular}
 
@@ -1194,7 +1194,7 @@ Legacy Interface. When used through the Legacy Interface,
 Transitional Devices must assume that Feature Bits 32 to 63
 are not acknowledged by Driver.
 
-As legacy devices had no configuration generation field,
+As legacy devices had no \field{config_generation} field,
 see \ref{sec:Basic Facilities of a Virtio Device / Configuration Space / Legacy Interface: Configuration Space}~\nameref{sec:Basic Facilities of a Virtio Device / Configuration Space / Legacy Interface: Configuration Space} for workarounds.
 
 \subsection{PCI-specific Initialization And Device Operation}\label{sec:Virtio Transport Options / Virtio Over PCI Bus / PCI-specific Initialization And Device Operation}
@@ -1249,12 +1249,11 @@ driver attempts to drive them:
 \paragraph{Queue Vector Configuration}\label{sec:Virtio Transport Options / Virtio Over PCI Bus / PCI-specific Initialization And Device Operation / Device Initialization / Queue Vector Configuration}
 
 When MSI-X capability is present and enabled in the device
-(through standard PCI configuration space) Configuration/Queue
-MSI-X Vector registers are used to map configuration change and queue
+(through standard PCI configuration space) \field{config_msix_vector} and \field{queue_msix_vector} are used to map configuration change and queue
 interrupts to MSI-X vectors. In this case, the ISR Status is unused.
 
-Writing a valid MSI-X Table entry number, 0 to 0x7FF, to one of
-Configuration/Queue Vector registers, maps interrupts triggered
+Writing a valid MSI-X Table entry number, 0 to 0x7FF, to
+\field{config_msix_vector}/\field{queue_msix_vector} maps interrupts triggered
 by the configuration change/selected queue events respectively to
 the corresponding MSI-X vector. To disable interrupts for a
 specific event type, unmap it by writing a special NO_VECTOR
@@ -1288,15 +1287,13 @@ configuration.
 The driver does this as follows, for each virtqueue a device has:
 
 \begin{enumerate}
-\item Write the virtqueue index (first queue is 0) to the Queue
-  Select field.
+\item Write the virtqueue index (first queue is 0) to \field{queue_select}.
 
-\item Read the virtqueue size from the Queue Size field, which MUST
+\item Read the virtqueue size from \field{queue_size}, which MUST
    be a power of 2. This controls how big the virtqueue is
   (see \ref{sec:Basic Facilities of a Virtio Device / Virtqueues}~\nameref{sec:Basic Facilities of a Virtio Device / Virtqueues}). If this field is 0, the virtqueue does not exist.
 
-\item Optionally, select a smaller virtqueue size and write it in the Queue Size
-   field.
+\item Optionally, select a smaller virtqueue size and write it to \field{queue_size}.
 
 \item Allocate and zero Descriptor Table, Available and Used rings for the
    virtqueue in contiguous physical memory.
@@ -1304,8 +1301,8 @@ The driver does this as follows, for each virtqueue a device has:
 \item Optionally, if MSI-X capability is present and enabled on the
   device, select a vector to use to request interrupts triggered
   by virtqueue events. Write the MSI-X Table entry number
-  corresponding to this vector in Queue Vector field. Read the
-  Queue Vector field: on success, previously written value is
+  corresponding to this vector into \field{queue_msix_vector}. Read
+  \field{queue_msix_vector}: on success, previously written value is
   returned; on failure, NO_VECTOR value is returned.
 \end{enumerate}
 
@@ -1324,7 +1321,7 @@ of this virtqueue to the Queue Notify address.  See \ref{sec:Virtio Transport Op
 
 \subsubsection{Virtqueue Interrupts From The Device}\label{sec:Virtio Transport Options / Virtio Over PCI Bus / PCI-specific Initialization And Device Operation / Virtqueue Interrupts From The Device}
 
-If an interrupt is necessary, the device SHOULD:
+If an interrupt is necessary for a virtqueue, the device SHOULD:
 
 \begin{itemize}
   \item If MSI-X capability is disabled:
@@ -1337,10 +1334,10 @@ If an interrupt is necessary, the device SHOULD:
   \item If MSI-X capability is enabled:
     \begin{enumerate}
     \item Request the appropriate MSI-X interrupt message for the
-      device, Queue Vector field sets the MSI-X Table entry
+      device, \field{queue_msix_vector} sets the MSI-X Table entry
       number.
 
-    \item If Queue Vector field value is NO_VECTOR, no interrupt
+    \item If the vector field value is NO_VECTOR, no interrupt
       message is requested for this event, so the device MUST NOT
       deliver an interrupt.
     \end{enumerate}
@@ -1377,8 +1374,8 @@ state, as reflected in the device-specific region of the device. In this case:
   MUST be scanned.
 
   \item If MSI-X capability is enabled: an interrupt message is
-  requested. The Configuration Vector field sets the MSI-X Table
-  entry number to use. If Configuration Vector field value is
+  requested. \field{config_msix_vector} sets the MSI-X Table
+  entry number to use. If \field{config_msix_vector} is
   NO_VECTOR, no interrupt message is requested for this event and
   the device MUST NOT deliver an interrupt.
 \end{itemize}
@@ -1425,7 +1422,7 @@ All register values are organized as Little Endian.
 
 
 \newcommand{\mmioreg}[5]{% Name Function Offset Direction Description
-  {\bf#1} \newline #3 \newline #4 & {\bf#2} \newline #5 \\
+  {\field{#1}} \newline #3 \newline #4 & {\bf#2} \newline #5 \\
 }
 
 \newcommand{\mmiodreg}[7]{% NameHigh NameLow Function OffsetHigh OffsetLow Direction Description
@@ -1474,42 +1471,42 @@ All register values are organized as Little Endian.
   \hline 
   \mmioreg{DeviceFeatures}{Flags representing features the device supports}{0x010}{R}{%
     Reading from this register returns 32 consecutive flag bits,
-    first bit depending on the last value written to the
-    DeviceFeaturesSel register. Access to this register returns
-    bits $DeviceFeaturesSel*32$ to $(DeviceFeaturesSel*32)+31$, eg.
-    feature bits 0 to 31 if DeviceFeaturesSel is set to 0 and
-    features bits 32 to 63 if DeviceFeaturesSel is set to 1.
+    first bit depending on the last value written to
+    \field{DeviceFeaturesSel}. Access to this register returns
+    bits $\field{DeviceFeaturesSel}*32$ to $(\field{DeviceFeaturesSel}*32)+31$, eg.
+    feature bits 0 to 31 if \field{DeviceFeaturesSel} is set to 0 and
+    features bits 32 to 63 if \field{DeviceFeaturesSel} is set to 1.
     Also see \ref{sec:Basic Facilities of a Virtio Device / Feature Bits}~\nameref{sec:Basic Facilities of a Virtio Device / Feature Bits}.
   }
   \hline 
   \mmioreg{DeviceFeaturesSel}{Device (host) features word selection.}{0x014}{W}{%
     Writing to this register selects a set of 32 device feature bits
-    accessible by reading from the DeviceFeatures register. The driver
-    MUST write a value to the DeviceFeaturesSel register before
-    reading from the DeviceFeatures register.
+    accessible by reading from \field{DeviceFeatures}. The driver
+    MUST write a value to \field{DeviceFeaturesSel} before
+    reading from \field{DeviceFeatures}.
   }
   \hline 
   \mmioreg{DriverFeatures}{Flags representing device features understood and activated by the driver}{0x020}{W}{%
     Writing to this register sets 32 consecutive flag bits, first
-    bit depending on the last value written to the DriverFeaturesSel
-    register. Access to this register sets bits $DriverFeaturesSel*32$
-    to $(DriverFeaturesSel*32)+31$, eg. feature bits 0 to 31 if
-    DriverFeaturesSel is set to 0 and features bits 32 to 63 if
-    DriverFeaturesSel is set to 1. Also see \ref{sec:Basic Facilities of a Virtio Device / Feature Bits}~\nameref{sec:Basic Facilities of a Virtio Device / Feature Bits}.
+    bit depending on the last value written to \field{DriverFeaturesSel}.
+     Access to this register sets bits $\field{DriverFeaturesSel}*32$
+    to $(\field{DriverFeaturesSel}*32)+31$, eg. feature bits 0 to 31 if
+    \field{DriverFeaturesSel} is set to 0 and features bits 32 to 63 if
+    \field{DriverFeaturesSel} is set to 1. Also see \ref{sec:Basic Facilities of a Virtio Device / Feature Bits}~\nameref{sec:Basic Facilities of a Virtio Device / Feature Bits}.
   }
   \hline 
   \mmioreg{DriverFeaturesSel}{Activated (guest) features word selection}{0x024}{W}{%
     Writing to this register selects a set of 32 activated feature
-    bits accessible by writing to the DriverFeatures register.
-    The driver MUST write a value to the DriverFeaturesSel
-    register before writing to the DriverFeatures register.
+    bits accessible by writing to \field{DriverFeatures}.
+    The driver MUST write a value to the \field{DriverFeaturesSel}
+    register before writing to the \field{DriverFeatures} register.
   }
   \hline 
   \mmioreg{QueueSel}{Virtual queue index}{0x030}{W}{%
     Writing to this register selects the virtual queue that the
-    following operations on the QueueNumMax, QueueNum, QueueReady,
-    QueueDescLow, QueueDescHigh, QueueAvailLow, QueueAvailHigh,
-    QueueUsedLow and QueueUsedHigh registers apply to. The index
+    following operations on \field{QueueNumMax}, \field{QueueNum}, \field{QueueReady},
+    \field{QueueDescLow}, \field{QueueDescHigh}, \field{QueueAvailLow}, \field{QueueAvailHigh},
+    \field{QueueUsedLow} and \field{QueueUsedHigh} apply to. The index
     number of the first queue is zero (0x0). 
   }
   \hline 
@@ -1517,8 +1514,8 @@ All register values are organized as Little Endian.
     Reading from the register returns the maximum size (number of
     elements) of the queue the device is ready to process or
     zero (0x0) if the queue is not available. This applies to the
-    queue selected by writing to QueueSel. The driver MUST NOT
-    access this register when the queue is in use (so when QueueReady
+    queue selected by writing to \field{QueueSel}. The driver MUST NOT
+    access this register when the queue is in use (so when \field{QueueReady}
     is not zero).
   }
   \hline 
@@ -1527,15 +1524,15 @@ All register values are organized as Little Endian.
     of the Descriptor Table and both Available and Used rings.
     Writing to this register notifies the device what size of the
     queue the driver will use. This applies to the queue selected by
-    writing to QueueSel. The driver MUST NOT access this register when
-    the queue is in use (so when QueueReady is not zero).
+    writing to \field{QueueSel}. The driver MUST NOT access this register when
+    the queue is in use (so when \field{QueueReady} is not zero).
   }
   \hline 
   \mmioreg{QueueReady}{Virtual queue ready bit}{0x044}{RW}{%
     Writing one (0x1) to this register notifies the device that the
     virtual queue is ready to be used. Reading from this register
     returns the last value written to it. Both read and write
-    accesses apply to the queue selected by writing to QueueSel.
+    accesses apply to the queue selected by writing to \field{QueueSel}.
     When the driver wants to stop using the queue it MUST write
     zero (0x0) to this register and MUST read the value back to
     ensure synchronisation.
@@ -1571,7 +1568,7 @@ All register values are organized as Little Endian.
     has been handled.
     When the driver finishes handling an interrupt, it MUST write
     a value to this register with bits corresponding to the handled
-    events (as defined for the InterruptStatus register) set, ie.
+    events (as defined for \field{InterruptStatus}) set, ie.
     equal one (1), and all other bits cleared, ie. equal zero (0).
   }
   \hline 
@@ -1581,35 +1578,35 @@ All register values are organized as Little Endian.
     Writing non-zero values to this register sets the status flags,
     indicating the driver progress. Writing zero (0x0) to this
     register triggers a device reset, including clearing all
-    bits in the InterruptStatus register and ready bits in the
-    QueueReady register for all queues in the device. 
+    bits in \field{InterruptStatus} and ready bits in the
+    \field{QueueReady} register for all queues in the device. 
     See also p. \ref{sec:Virtio Transport Options / Virtio Over MMIO / MMIO-specific Initialization And Device Operation / Device Initialization}~\nameref{sec:Virtio Transport Options / Virtio Over MMIO / MMIO-specific Initialization And Device Operation / Device Initialization}.
   }
   \hline 
   \mmiodreg{QueueDescLow}{QueueDescHigh}{Virtual queue's Descriptor Table 64 bit long physical address}{0x080}{0x084}{W}{%
     Writing to these two registers (lower 32 bits of the address
-    to QueueDescLow, higher 32 bits to QueueDescHigh) notifies
+    to \field{QueueDescLow}, higher 32 bits to \field{QueueDescHigh}) notifies
     the device about location of the Descriptor Table of the queue
-    selected by writing to the QueueSel register. The driver MUST NOT
-    access this register when the queue is in use (so when QueueReady
+    selected by writing to \field{QueueSel} register. The driver MUST NOT
+    access this register when the queue is in use (so when \field{QueueReady}
     is not zero).
   }
   \hline 
   \mmiodreg{QueueAvailLow}{QueueAvailHigh}{Virtual queue's Available Ring 64 bit long physical address}{0x090}{0x094}{W}{%
     Writing to these two registers (lower 32 bits of the address
-    to QueueAvailLow, higher 32 bits to QueueAvailHigh) notifies
+    to \field{QueueAvailLow}, higher 32 bits to \field{QueueAvailHigh}) notifies
     the device about location of the Available Ring of the queue
-    selected by writing to the QueueSel register. The driver MUST NOT
-    access this register when the queue is in use (so when QueueReady
+    selected by writing to \field{QueueSel}. The driver MUST NOT
+    access this register when the queue is in use (so when \field{QueueReady}
     is not zero).
   }
   \hline 
   \mmiodreg{QueueUsedLow}{QueueUsedHigh}{Virtual queue's Used Ring 64 bit long physical address}{0x0a0}{0x0a4}{W}{%
     Writing to these two registers (lower 32 bits of the address
-    to QueueUsedLow, higher 32 bits to QueueUsedHigh) notifies
+    to \field{QueueUsedLow}, higher 32 bits to \field{QueueUsedHigh}) notifies
     the device about location of the Used Ring of the queue
-    selected by writing to the QueueSel register. The driver MUST NOT
-    access this register when the queue is in use (so when QueueReady
+    selected by writing to \field{QueueSel}. The driver MUST NOT
+    access this register when the queue is in use (so when \field{QueueReady}
     is not zero).
   }
   \hline 
@@ -1633,8 +1630,8 @@ All register values are organized as Little Endian.
 \subsubsection{Device Initialization}\label{sec:Virtio Transport Options / Virtio Over MMIO / MMIO-specific Initialization And Device Operation / Device Initialization}
 
 The driver MUST start the device initialization by reading and
-checking values from the MagicValue and the Version registers.
-If both values are valid, it MUST read the DeviceID register
+checking values from \field{MagicValue} and \field{Version}.
+If both values are valid, it MUST read \field{DeviceID}
 and if its value is zero (0x0) MUST abort initialization and
 MUST NOT access any other register.
 
@@ -1646,14 +1643,14 @@ Further initialization MUST follow the procedure described in
 The driver MUST initialize the virtual queue in the following way:
 
 \begin{enumerate}
-\item Select the queue writing its index (first queue is 0) to the
-   QueueSel register.
+\item Select the queue writing its index (first queue is 0) to
+   \field{QueueSel}.
 
-\item Check if the queue is not already in use: read the QueueReady
-   register, returned value should be zero (0x0).
+\item Check if the queue is not already in use: read \field{QueueReady},
+   returned value should be zero (0x0).
 
-\item Read maximum queue size (number of elements) from the
-   QueueNumMax register. If the returned value is zero (0x0) the
+\item Read maximum queue size (number of elements) from
+   \field{QueueNumMax}. If the returned value is zero (0x0) the
    queue is not available.
 
 \item Allocate and zero the queue pages, making sure the memory
@@ -1663,32 +1660,33 @@ The driver MUST initialize the virtual queue in the following way:
    the maximum size returned by the device.
 
 \item Notify the device about the queue size by writing the size to
-   the QueueNum register.
+   \field{QueueNum}.
 
 \item Write physical addresses of the queue's Descriptor Table,
-   Available Ring and Used Ring to (respectively) the QueueDescLow/
-   QueueDescHigh, QueueAvailLow/QueueAvailHigh and QueueUsedLow/
-   QueueUsedHigh register pairs.
+   Available Ring and Used Ring to (respectively) the
+   \field{QueueDescLow}/\field{QueueDescHigh},
+   \field{QueueAvailLow}/\field{QueueAvailHigh} and
+   \field{QueueUsedLow}/\field{QueueUsedHigh} register pairs.
 
-\item Write 0x1 to the QueueReady register.
+\item Write 0x1 to \field{QueueReady}.
 \end{enumerate}
 
 \subsubsection{Notifying The Device}\label{sec:Virtio Transport Options / Virtio Over MMIO / MMIO-specific Initialization And Device Operation / Notifying The Device}
 
 The driver MUST notify the device about new buffers being available in
-a queue by writing the index of the updated queue to the QueueNotify register.
+a queue by writing the index of the updated queue to \field{QueueNotify}.
 
 \subsubsection{Notifications From The Device}\label{sec:Virtio Transport Options / Virtio Over MMIO / MMIO-specific Initialization And Device Operation / Notifications From The Device}
 
 The memory mapped virtio device is using a single, dedicated
 interrupt signal, which is asserted when at least one of the
-bits described in the InterruptStatus register
-description is set. This way the device may notify the
+bits described in the description of \field{InterruptStatus}
+is set. This way the device may notify the
 driver about a new used buffer being available in the queue
 or about a change in the device configuration.
 
-After receiving an interrupt, the driver MUST read the
-InterruptStatus register to check what caused the interrupt
+After receiving an interrupt, the driver MUST read
+\field{InterruptStatus} to check what caused the interrupt
 (see the register description). After the interrupt is handled,
 the driver MUST acknowledge it by writing a bit mask
 corresponding to the handled events to the InterruptACK register.
@@ -1745,8 +1743,8 @@ nor behaviour:
   \hline
   \mmioreg{QueueSel}{Virtual queue index}{0x030}{W}{%
     Writing to this register selects the virtual queue that the
-    following operations on the QueueNumMAx, QueueNum, QueueAlign
-    and QueuePFN registers apply to. The index
+    following operations on the \field{QueueNumMax}, \field{QueueNum}, \field{QueueAlign}
+    and \field{QueuePFN} registers apply to. The index
     number of the first queue is zero (0x0). 
 .
   }
@@ -1754,8 +1752,8 @@ nor behaviour:
   \mmioreg{QueueNumMax}{Maximum virtual queue size}{0x034}{R}{%
     Reading from the register returns the maximum size of the queue
     the device is ready to process or zero (0x0) if the queue is not
-    available. This applies to the queue selected by writing to the
-    QueueSel and is allowed only when the QueuePFN is set to zero
+    available. This applies to the queue selected by writing to
+    \field{QueueSel} and is allowed only when \field{QueuePFN} is set to zero
     (0x0), so when the queue is not actively used.
   }
   \hline
@@ -1764,14 +1762,13 @@ nor behaviour:
     of the descriptor table and both available and used rings.
     Writing to this register notifies the device what size of the
     queue the driver will use. This applies to the queue selected by
-    writing to the QueueSel register.
+    writing to \field{QueueSel}.
   }
   \hline
   \mmioreg{QueueAlign}{Used Ring alignment in the virtual queue}{0x03c}{W}{%
     Writing to this register notifies the device about alignment
     boundary of the Used Ring in bytes. This value MUST be a power
-    of 2 and applies to the queue selected by writing to the QueueSel
-    register.
+    of 2 and applies to the queue selected by writing to \field{QueueSel}.
   }
   \hline
   \mmioreg{QueuePFN}{Guest physical page number of the virtual queue}{0x040}{RW}{%
@@ -1785,7 +1782,7 @@ nor behaviour:
     number of the queue, therefore a value other than zero (0x0)
     means that the queue is in use.
     Both read and write accesses apply to the queue selected by
-    writing to the QueueSel register.
+    writing to \field{QueueSel}.
   }
   \hline
   \mmioreg{QueueNotify}{Queue notifier}{0x050}{W}{}
@@ -1800,7 +1797,7 @@ nor behaviour:
     Writing non-zero values to this register sets the status flags,
     indicating the OS/driver progress. Writing zero (0x0) to this
     register triggers a device reset. This should include
-    setting QueuePFN to zero (0x0) for all queues in the device.
+    setting \field{QueuePFN} to zero (0x0) for all queues in the device.
     Also see \ref{sec:General Initialization And Device Operation / Device Initialization}~\nameref{sec:General Initialization And Device Operation / Device Initialization}.
   }
   \hline
@@ -1808,24 +1805,24 @@ nor behaviour:
   \hline
 \end{longtable}
 
-The virtual queue page size is defined by writing to the GuestPageSize
-register, as written by the guest. This must be done before the
+The virtual queue page size is defined by writing to \field{GuestPageSize},
+as written by the guest. This must be done before the
 virtual queues are configured.
 
 The virtual queue layout follows
 p. \ref{sec:Basic Facilities of a Virtio Device / Virtqueues / Legacy Interfaces: A Note on Virtqueue Layout}~\nameref{sec:Basic Facilities of a Virtio Device / Virtqueues / Legacy Interfaces: A Note on Virtqueue Layout},
-with the alignment defined in the QueueAlign register.
+with the alignment defined in \field{QueueAlign}.
 
 The virtual queue is configured as follows:
 \begin{enumerate}
-\item Select the queue writing its index (first queue is 0) to the
-   QueueSel register.
+\item Select the queue writing its index (first queue is 0) to
+   \field{QueueSel}.
 
-\item Check if the queue is not already in use: read the QueuePFN
-   register, returned value should be zero (0x0).
+\item Check if the queue is not already in use: read \field{QueuePFN},
+   returned value should be zero (0x0).
 
-\item Read maximum queue size (number of elements) from the
-   QueueNumMax register. If the returned value is zero (0x0) the
+\item Read maximum queue size (number of elements) from
+   \field{QueueNumMax}. If the returned value is zero (0x0) the
    queue is not available.
 
 \item Allocate and zero the queue pages in contiguous virtual
@@ -1834,13 +1831,13 @@ The virtual queue is configured as follows:
    equal to the maximum size returned by the device.
 
 \item Notify the device about the queue size by writing the size to
-   the QueueNum register.
+   \field{QueueNum}.
 
 \item Notify the device about the used alignment by writing its value
-   in bytes to the QueueAlign register.
+   in bytes to \field{QueueAlign}.
 
 \item Write the physical number of the first page of the queue to
-   the QueuePFN register.
+   the \field{QueuePFN} register.
 \end{enumerate}
 
 Notification mechanisms did not change.
@@ -1955,14 +1952,14 @@ struct virtio_rev_info {
 };
 \end{lstlisting}
 
-revision contains the desired revision id, length the length of the
-data portion and data revision-dependent additional desired options.
+\field{revision} contains the desired revision id, \field{length} the length of the
+data portion and \field{data} revision-dependent additional desired options.
 
 The following values are supported:
 
 \begin{tabular}{ |l|l|l|l| }
 \hline
-revision & length & data      & remarks \\
+\field{revision} & \field{length} & \field{data}      & remarks \\
 \hline \hline
 0        & 0      & <empty>   & legacy interface; transitional devices only \\
 \hline
@@ -1975,9 +1972,9 @@ revision & length & data      & remarks \\
 Note that a change in the virtio standard does not necessarily
 correspond to a change in the virtio-ccw revision.
 
-A device MUST post a unit check with command reject for any revision
-it does not support. For any invalid combination of revision, length
-and data, it MUST post a unit check with command reject as well. A
+A device MUST post a unit check with command reject for any \field{revision}
+it does not support. For any invalid combination of \field{revision}, \field{length}
+and \field{data}, it MUST post a unit check with command reject as well. A
 non-transitional device MUST reject revision id 0.
 
 A driver SHOULD start with trying to set the highest revision it
@@ -2026,8 +2023,8 @@ struct vq_config_block {
 } __attribute__ ((packed));
 \end{lstlisting}
 
-The requested number of buffers for queue index is returned in
-max_num.
+The requested number of buffers for queue \field{index} is returned in
+\field{max_num}.
 
 Afterwards, CCW_CMD_SET_VQ is issued by the driver to inform the
 device about the location used for its queue. The transmitted
@@ -2044,10 +2041,10 @@ struct vq_info_block {
 } __attribute__ ((packed));
 \end{lstlisting}
 
-desc, avail and used contain the guest addresses for the descriptor table,
-available ring and used ring for queue index, respectively. The actual
-virtqueue size (number of allocated buffers) is transmitted in num.
-res0 is reserved and MUST be ignored by the device.
+\field{desc}, \field{avail} and \field{used} contain the guest addresses for the descriptor table,
+available ring and used ring for queue \field{index}, respectively. The actual
+virtqueue size (number of allocated buffers) is transmitted in \field{num}.
+\field{res0} is reserved and MUST be ignored by the device.
 
 \paragraph{Legacy Interface: A Note on Configuring a Virtqueue}\label{sec:Virtio Transport Options / Virtio over channel I/O / Device Initialization / Configuring a Virtqueue / Legacy Interface: A Note on Configuring a Virtqueue}
 
@@ -2063,8 +2060,8 @@ struct vq_info_block_legacy {
 } __attribute__ ((packed));
 \end{lstlisting}
 
-queue contains the guest address for queue index, num the number of buffers
-and align the alignment.
+\field{queue} contains the guest address for queue \field{index}, \field{num} the number of buffers
+and \field{align} the alignment.
 
 \subsubsection{Virtqueue Layout}\label{sec:Virtio Transport Options / Virtio over channel I/O / Device Initialization / Virtqueue Layout}
 
@@ -2111,16 +2108,16 @@ struct virtio_feature_desc {
 } __attribute__ ((packed));
 \end{lstlisting}
 
-features are the 32 bits of features currently accessed, while
-index describes which of the feature bit values is to be
+\field{features} are the 32 bits of features currently accessed, while
+\field{index} describes which of the feature bit values is to be
 accessed.
 
 The guest obtains the device's device feature set via the
-CCW_CMD_READ_FEAT command. The device stores the features at index
-to features.
+CCW_CMD_READ_FEAT command. The device stores the features at \field{index}
+to \field{features}.
 
 For communicating its supported features to the device, the driver
-uses the CCW_CMD_WRITE_FEAT command, denoting a features/index
+uses the CCW_CMD_WRITE_FEAT command, denoting a \field{features}/\field{index}
 combination.
 
 \subsubsection{Device Configuration}\label{sec:Virtio Transport Options / Virtio over channel I/O / Device Initialization / Device Configuration}
@@ -2201,13 +2198,13 @@ struct virtio_thinint_area {
 } __attribute__ ((packed));
 \end{lstlisting}
 
-summary_indicator contains the guest address of the 8 bit summary
+\field{summary_indicator} contains the guest address of the 8 bit summary
 indicator.
-indicator contains the guest address of an area wherin the indicators
-for the devices are contained, starting at bit_nr, one bit per
+\field{indicator} contains the guest address of an area wherin the indicators
+for the devices are contained, starting at \field{bit_nr}, one bit per
 virtqueue of the device. Bit numbers start at the left, i.e. the most
 significant bit in the first byte is assigned the bit number 0.
-isc contains the I/O interruption subclass to be used for the adapter
+\field{isc} contains the I/O interruption subclass to be used for the adapter
 I/O interrupt. It may be different from the isc used by the proxy
 virtio-ccw device's subchannel.
 
@@ -2388,7 +2385,7 @@ features.
 \end{description}
 
  N=0 if VIRTIO_NET_F_MQ is not negotiated, otherwise N is derived
- from max_virtqueue_pairs control field.
+ from \field{max_virtqueue_pairs} control field.
 
  controlq only exists if VIRTIO_NET_F_CTRL_VQ set.
 
@@ -2452,9 +2449,9 @@ were required.
 
 \subsection{Device configuration layout}\label{sec:Device Types / Network Device / Device configuration layout}
 
-Three configuration fields are currently defined. The mac address field
+Three configuration fields are currently defined. The \field{mac} address field
 always exists (though is only valid if VIRTIO_NET_F_MAC is set), and
-the status field only exists if VIRTIO_NET_F_STATUS is set. Two
+\field{status} only exists if VIRTIO_NET_F_STATUS is set. Two
 read-only bits (for the driver) are currently defined for the status field:
 VIRTIO_NET_S_LINK_UP and VIRTIO_NET_S_ANNOUNCE.
 
@@ -2463,11 +2460,11 @@ VIRTIO_NET_S_LINK_UP and VIRTIO_NET_S_ANNOUNCE.
 #define VIRTIO_NET_S_ANNOUNCE    2
 \end{lstlisting}
 
-The following driver-read-only field, max_virtqueue_pairs only exists if
+The following driver-read-only field, \field{max_virtqueue_pairs} only exists if
 VIRTIO_NET_F_MQ is set. This field specifies the maximum number
 of each of transmit and receive virtqueues (receiveq0..receiveqN
 and transmitq0..transmitqN respectively;
- N=max_virtqueue_pairs - 1) that can be configured once VIRTIO_NET_F_MQ
+ N=\field{max_virtqueue_pairs} - 1) that can be configured once VIRTIO_NET_F_MQ
 is negotiated.  Legal values for this field are 1 to 0x8000.
 
 \begin{lstlisting}
@@ -2480,7 +2477,7 @@ struct virtio_net_config {
 \end{lstlisting}
 
 \subsubsection{Legacy Interface: Device configuration layout}\label{sec:Device Types / Network Device / Device configuration layout / Legacy Interface: Device configuration layout}
-For legacy devices, the status and max_virtqueue_pairs fields in struct virtio_net_config are the
+For legacy devices, \field{status} and \field{max_virtqueue_pairs} in struct virtio_net_config are the
 native endian of the guest rather than (necessarily) little-endian.
 
 
@@ -2490,10 +2487,10 @@ native endian of the guest rather than (necessarily) little-endian.
 \item The initialization routine should identify the receive and
   transmission virtqueues, up to N+1 of each kind. If
   VIRTIO_NET_F_MQ feature bit is negotiated,
-  N=max_virtqueue_pairs-1, otherwise identify N=0.
+  N=\field{max_virtqueue_pairs}-1, otherwise identify N=0.
 
 \item If the VIRTIO_NET_F_MAC feature bit is set, the configuration
-  space “mac” entry indicates the “physical” address of the the
+  space \field{mac} entry indicates the “physical” address of the
   network card, otherwise a private MAC address should be
   assigned. All drivers are expected to negotiate this feature if
   it is set.
@@ -2502,14 +2499,14 @@ native endian of the guest rather than (necessarily) little-endian.
   identify the control virtqueue.
 
 \item If the VIRTIO_NET_F_STATUS feature bit is negotiated, the link
-  status can be read from the bottom bit of the “status” config
-  field. Otherwise, the link should be assumed active.
+  status can be read from the bottom bit of \field{status}.
+  Otherwise, the link should be assumed active.
 
 \item Only receiveq0, transmitq0 and controlq are used by default.
   To use more queues driver must negotiate the VIRTIO_NET_F_MQ
-  feature; initialize up to max_virtqueue_pairs of each of
+  feature; initialize up to \field{max_virtqueue_pairs} of each of
   transmit and receive queues;
-  execute_VIRTIO_NET_CTRL_MQ_VQ_PAIRS_SET command specifying the
+  execute VIRTIO_NET_CTRL_MQ_VQ_PAIRS_SET command specifying the
   number of the transmit and receive queues that is going to be
   used and wait until the device consumes the controlq buffer and
   acks this command.
@@ -2523,7 +2520,7 @@ native endian of the guest rather than (necessarily) little-endian.
   “checksum offload” is a common feature on modern network cards.
 
 \item If that feature is negotiated\footnote{ie. VIRTIO_NET_F_HOST_TSO* and VIRTIO_NET_F_HOST_UFO are
-dependent on VIRTIO_NET_F_CSUM; a dvice which offers the offload
+dependent on VIRTIO_NET_F_CSUM; a device which offers the offload
 features must offer the checksum feature, and a driver which
 accepts the offload features must accept the checksum feature.
 Similar logic applies to the VIRTIO_NET_F_GUEST_TSO4 features
@@ -2595,20 +2592,20 @@ the different features the driver negotiated.
   are set as follows. Otherwise, the packet must be fully
   checksummed, and flags is zero.
   \begin{itemize}
-  \item flags has the VIRTIO_NET_HDR_F_NEEDS_CSUM set,
+  \item \field{flags} has the VIRTIO_NET_HDR_F_NEEDS_CSUM set,
 
-  \item csum_start is set to the offset within the packet to begin checksumming,
+  \item \field{csum_start} is set to the offset within the packet to begin checksumming,
     and
 
-  \item csum_offset indicates how many bytes after the csum_start the
+  \item \field{csum_offset} indicates how many bytes after the csum_start the
     new (16 bit ones' complement) checksum should be placed.
   \end{itemize}
 
 For example, consider a partially checksummed TCP (IPv4) packet.
 It will have a 14 byte ethernet header and 20 byte IP header
 followed by the TCP header (with the TCP checksum field 16 bytes
-into that header). csum_start will be 14+20 = 34 (the TCP
-checksum includes the header), and csum_offset will be 16. The
+into that header). \field{csum_start} will be 14+20 = 34 (the TCP
+checksum includes the header), and \field{csum_offset} will be 16. The
 value in the TCP checksum field should be initialized to the sum
 of the TCP pseudo header, so that replacing it by the ones'
 complement checksum of the TCP header and body will give the
@@ -2616,32 +2613,32 @@ correct result.
 
 \item If the driver negotiated
   VIRTIO_NET_F_HOST_TSO4, TSO6 or UFO, and the packet requires
-  TCP segmentation or UDP fragmentation, then the “gso_type”
-  field is set to VIRTIO_NET_HDR_GSO_TCPV4, TCPV6 or UDP.
+  TCP segmentation or UDP fragmentation, then \field{gso_type}
+  is set to VIRTIO_NET_HDR_GSO_TCPV4, TCPV6 or UDP.
   (Otherwise, it is set to VIRTIO_NET_HDR_GSO_NONE). In this
   case, packets larger than 1514 bytes can be transmitted: the
   metadata indicates how to replicate the packet header to cut it
   into smaller packets. The other gso fields are set:
 
   \begin{itemize}
-  \item hdr_len is a hint to the device as to how much of the header
+  \item \field{hdr_len} is a hint to the device as to how much of the header
     needs to be kept to copy into each packet, usually set to the
     length of the headers, including the transport header.\footnote{Due to various bugs in implementations, this field is not useful
 as a guarantee of the transport header size.
 }
 
-  \item gso_size is the maximum size of each packet beyond that
+  \item \field{gso_size} is the maximum size of each packet beyond that
     header (ie. MSS).
 
   \item If the driver negotiated the VIRTIO_NET_F_HOST_ECN feature,
-    the VIRTIO_NET_HDR_GSO_ECN bit may be set in “gso_type” as
+    the VIRTIO_NET_HDR_GSO_ECN bit may be set in \field{gso_type} as
     well, indicating that the TCP packet has the ECN bit set.\footnote{This case is not handled by some older hardware, so is called out
 specifically in the protocol.
 }
    \end{itemize}
 
 \item If the driver negotiated the VIRTIO_NET_F_MRG_RXBUF feature,
-  the num_buffers field is set to zero.
+  \field{num_buffers} is set to zero.
 
 \item The header and packet are added as one output buffer to the
   transmitq, and the device is notified of the new entry
@@ -2694,28 +2691,28 @@ Processing packet involves:
 
 \begin{enumerate}
 \item If the driver negotiated the VIRTIO_NET_F_MRG_RXBUF feature,
-  then the “num_buffers” field indicates how many descriptors
+  then \field{num_buffers} indicates how many descriptors
   this packet is spread over (including this one). This allows
   receipt of large packets without having to allocate large
-  buffers. In this case, there will be at least “num_buffers” in
+  buffers. In this case, there will be at least \field{num_buffers} in
   the used ring, and they should be chained together to form a
   single packet. The other buffers will not begin with a struct
   virtio_net_hdr.
 
 \item If the VIRTIO_NET_F_MRG_RXBUF feature was not negotiated, or
-  the “num_buffers” field is one, then the entire packet will be
+  \field{num_buffers} is one, then the entire packet will be
   contained within this buffer, immediately following the struct
   virtio_net_hdr.
 
 \item If the VIRTIO_NET_F_GUEST_CSUM feature was negotiated, the
-  VIRTIO_NET_HDR_F_NEEDS_CSUM bit in the “flags” field may be
-  set: if so, the checksum on the packet is incomplete and the “
-  csum_start” and “csum_offset” fields indicate how to calculate
+  VIRTIO_NET_HDR_F_NEEDS_CSUM bit in \field{flags} may be
+  set: if so, the checksum on the packet is incomplete and
+  \field{csum_start} and \field{csum_offset} indicate how to calculate
   it (see Packet Transmission point 1).
 
 \item If the VIRTIO_NET_F_GUEST_TSO4, TSO6 or UFO options were
-  negotiated, then the “gso_type” may be something other than
-  VIRTIO_NET_HDR_GSO_NONE, and the “gso_size” field indicates the
+  negotiated, then \field{gso_type} may be something other than
+  VIRTIO_NET_HDR_GSO_NONE, and \field{gso_size} field indicates the
   desired MSS (see Packet Transmission point 2).
 \end{enumerate}
 
@@ -2741,9 +2738,9 @@ struct virtio_net_ctrl {
 #define VIRTIO_NET_ERR    1
 \end{lstlisting}
 
-The class, command and command-specific-data are set by the
-driver, and the device sets the ack byte. There is little it can
-do except issue a diagnostic if the ack byte is not
+The \field{class}, \field{command} and command-specific-data are set by the
+driver, and the device sets the \field{ack} byte. There is little it can
+do except issue a diagnostic if \field{ack} is not
 VIRTIO_NET_OK.
 
 \paragraph{Packet Receive Filtering}\label{sec:Device Types / Network Device / Device Operation / Control Virtqueue / Packet Receive Filtering}
@@ -2792,39 +2789,39 @@ command-specific-data is two variable length tables of 6-byte MAC
 addresses. The first table contains unicast addresses, and the second
 contains multicast addresses.
 
-When VIRTIO_NET_F_MAC_ADDR is not negotiated, the mac field in
+When VIRTIO_NET_F_MAC_ADDR is not negotiated, \field{mac} in the
 config space is writeable and is used to set the default MAC
 address which rx filtering accepts.
-When VIRTIO_NET_F_MAC_ADDR is negotiated, the mac field in
+When VIRTIO_NET_F_MAC_ADDR is negotiated, \field{mac} in the
 config space becomes read-only for the driver.
 The VIRTIO_NET_CTRL_MAC_ADDR_SET command is used to set the
 default MAC address which rx filtering
-accepts
+accepts.
 
 Depending on whether VIRTIO_NET_F_MAC_ADDR has been negotiated,
-the mac field in config space or the VIRTIO_NET_CTRL_MAC_ADDR_SET
+\field{mac} in config space or the VIRTIO_NET_CTRL_MAC_ADDR_SET
 is used to set the default MAC address which rx filtering
 accepts.
 The command-specific-data for VIRTIO_NET_CTRL_MAC_ADDR_SET is
 the 6-byte MAC address.
 
 The
-VIRTIO_NET_CTRL_MAC_ADDR_SET command is atomic whereas the
-mac field in config space is not, therefore drivers
+VIRTIO_NET_CTRL_MAC_ADDR_SET command is atomic whereas
+\field{mac} in config space is not, therefore drivers
 MUST negotiate VIRTIO_NET_F_MAC_ADDR if they change
 mac address when device is accepting incoming packets.
 
 \subparagraph{Legacy Interface: Setting MAC Address Filtering}\label{sec:Device Types / Network Device / Device Operation / Control Virtqueue / Setting MAC Address Filtering / Legacy Interface: Setting MAC Address Filtering}
-For legacy devices, the entries field in struct virtio_net_ctrl_mac is the
+For legacy devices, \field{entries} in struct virtio_net_ctrl_mac is the
 native endian of the guest rather than (necessarily) little-endian.
 
 Legacy drivers that didn't negotiate VIRTIO_NET_F_MAC_ADDR
-changed the mac field in config space when NIC is accepting
+changed \field{mac} in config space when NIC is accepting
 incoming packets. These drivers always wrote the mac value from
 first to last byte, therefore after detecting such drivers,
-a transitional device CAN defer MAC update, or CAN defer
+a transitional device MAY defer MAC update, or MAY defer
 processing incoming packets until driver writes the last byte
-of the mac field in config space.
+of \field{mac} in the config space.
 
 \paragraph{VLAN Filtering}\label{sec:Device Types / Network Device / Device Operation / Control Virtqueue / VLAN Filtering}
 
@@ -2903,7 +2900,7 @@ the number of the transmit and receive queues to be used; subsequently,
 transmitq0..transmitqn and receiveq0..receiveqn where
 n=virtqueue_pairs-1 MAY be used. All these virtqueues MUST have
 been pre-configured in advance. The range of legal values for the
-virtqueue_pairs field is between 1 and max_virtqueue_pairs.
+\field{virtqueue_pairs} field is between 1 and \field{max_virtqueue_pairs}.
 
 When multiqueue is enabled, the device MUST use automatic receive steering
 based on packet flow. Programming of the receive steering
@@ -2913,7 +2910,7 @@ be steered to receiveqX. For uni-directional protocols, or where
 no packets have been transmitted yet, the device MAY steer a packet
 to a random queue out of the specified receiveq0..receiveqn.
 
-Multiqueue is disabled by setting virtqueue_pairs = 1 (this is
+Multiqueue is disabled by setting \field{virtqueue_pairs} to 1 (this is
 the default). After the command has been consumed by the device, the
 device MUST NOT steer new packets to virtqueues
 receveq1..receiveqN (i.e. other than receiveq0) and MUST NOT read from
@@ -2922,7 +2919,7 @@ the driver MUST NOT transmit new packets on virtqueues other than
 transmitq0.
 
 \subparagraph{Legacy Interface: Automatic receive steering in multiqueue mode}\label{sec:Device Types / Network Device / Device Operation / Control Virtqueue / Automatic receive steering in multiqueue mode / Legacy Interface: Automatic receive steering in multiqueue mode}
-For legacy devices, the virtqueue_paris field is in the
+For legacy devices, \field{virtqueue_pairs} is in the
 native endian of the guest rather than (necessarily) little-endian.
 
 \paragraph{Offloads State Configuration}\label{sec:Device Types / Network Device / Device Operation / Control Virtqueue / Offloads State Configuration}
@@ -2960,7 +2957,7 @@ change of specific offload state.
 
 
 \subparagraph{Legacy Interface: Setting Offloads State}\label{sec:Device Types / Network Device / Device Operation / Control Virtqueue / Offloads State Configuration / Setting Offloads State / Legacy Interface: Setting Offloads State}
-For legacy devices, the offloads field is the
+For legacy devices, \field{offloads} is the
 native endian of the guest rather than (necessarily) little-endian.
 
 
@@ -2983,17 +2980,17 @@ device except where noted.
 
 \begin{description}
 \item[VIRTIO_BLK_F_SIZE_MAX (1)] Maximum size of any single segment is
-    in “size_max”.
+    in \field{size_max}.
 
 \item[VIRTIO_BLK_F_SEG_MAX (2)] Maximum number of segments in a
-    request is in “seg_max”.
+    request is in \field{seg_max}.
 
-\item[VIRTIO_BLK_F_GEOMETRY (4)] Disk-style geometry specified in “
-    geometry”.
+\item[VIRTIO_BLK_F_GEOMETRY (4)] Disk-style geometry specified in
+    \field{geometry}.
 
 \item[VIRTIO_BLK_F_RO (5)] Device is read-only.
 
-\item[VIRTIO_BLK_F_BLK_SIZE (6)] Block size of disk is in “blk_size”.
+\item[VIRTIO_BLK_F_BLK_SIZE (6)] Block size of disk is in \field{blk_size}.
 
 \item[VIRTIO_BLK_F_TOPOLOGY (10)] Device exports information on optimal I/O
     alignment.
@@ -3018,7 +3015,7 @@ VIRTIO_BLK_T_FLUSH commands.
 
 \subsubsection{Device configuration layout}\label{sec:Device Types / Block Device / Feature bits / Device configuration layout}
 
-The capacity of the device (expressed in 512-byte sectors) is always
+The \field{capacity} of the device (expressed in 512-byte sectors) is always
 present. The availability of the others all depend on various feature
 bits as indicated above.
 
@@ -3057,12 +3054,12 @@ native endian of the guest rather than (necessarily) little-endian.
 \subsection{Device Initialization}\label{sec:Device Types / Block Device / Device Initialization}
 
 \begin{enumerate}
-\item The device size should be read from the “capacity”
-  configuration field. No requests should be submitted which goes
+\item The device size should be read from \field{capacity}.
+  No requests should be submitted which goes
   beyond this limit.
 
-\item If the VIRTIO_BLK_F_BLK_SIZE feature is negotiated, the
-  blk_size field can be read to determine the optimal sector size
+\item If the VIRTIO_BLK_F_BLK_SIZE feature is negotiated,
+  \field{blk_size} can be read to determine the optimal sector size
   for the driver to use. This does not affect the units used in
   the protocol (always 512 bytes), but awareness of the correct
   value can affect performance.
@@ -3071,16 +3068,16 @@ native endian of the guest rather than (necessarily) little-endian.
   requests will fail.
 
 \item If the VIRTIO_BLK_F_TOPOLOGY feature is negotiated, the fields in the
-  topology struct can be read to determine the physical block size and optimal
+  \field{topology} struct can be read to determine the physical block size and optimal
   I/O lengths for the driver to use. This also does not affect the units
   in the protocol, only performance.
 \end{enumerate}
 
 \subsubsection{Legacy Interface: Device Initialization}\label{sec:Device Types / Block Device / Device Initialization / Legacy Interface: Device Initialization}
 
-The reserved field used to be called writeback.  If the
+The \field{reserved} field used to be called \field{writeback}.  If the
 VIRTIO_BLK_F_CONFIG_WCE feature is offered, the cache mode should be
-read from the writeback field of the configuration if available; the
+read from \field{writeback} if available; the
 driver can also write to the field in order to toggle the cache
 between writethrough (0) and writeback (1) mode.  If the feature is
 not available, the driver can instead look at the result of
@@ -3118,11 +3115,11 @@ distinguish between them
 #define VIRTIO_BLK_T_FLUSH_OUT    5
 \end{lstlisting}
 
-The sector number indicates the offset (multiplied by 512) where
+The \field{sector} number indicates the offset (multiplied by 512) where
 the read or write is to occur. This field is unused and set to 0
 for scsi packet commands and for flush commands.
 
-The final status byte is written by the device: either
+The final \field{status} byte is written by the device: either
 VIRTIO_BLK_S_OK for success, VIRTIO_BLK_S_IOERR for device or driver
 error or VIRTIO_BLK_S_UNSUPP for a request unsupported by device:
 
@@ -3139,7 +3136,7 @@ be committed to non-volatile storage by the device.
 For legacy devices, the fields in struct virtio_blk_req are the
 native endian of the guest rather than (necessarily) little-endian.
 
-The 'reserved' field was previously called ioprio.  The ioprio field
+The \field{reserved} field was previously called \field{ioprio}.  \field{ioprio}
 is a hint about the relative priorities of requests to the device:
 higher numbers indicate more important requests.
 
@@ -3186,38 +3183,38 @@ does not distinguish between them:
 #define VIRTIO_BLK_T_SCSI_CMD_OUT 3
 \end{lstlisting}
 
-The cmd field is only present for scsi packet command requests,
+The \field{cmd} field is only present for scsi packet command requests,
 and indicates the command to perform. This field must reside in a
 single, separate device-readable buffer; command length can be derived
 from the length of this buffer.
 
 Note that these first three (four for scsi packet commands)
-fields are always device-readable: the data field is either device-readable
+fields are always device-readable: \field{data} is either device-readable
 or device-writable, depending on the request. The size of the read or
 write can be derived from the total size of the request buffers.
 
-The sense field is only present for scsi packet command requests,
+\field{sense} is only present for scsi packet command requests,
 and indicates the buffer for scsi sense data.
 
-The data_len field is only present for scsi packet command
+\field{data_len} is only present for scsi packet command
 requests, this field is deprecated, and should be ignored by the
 driver. Historically, devices copied data length there.
 
-The sense_len field is only present for scsi packet command
+\field{sense_len} is only present for scsi packet command
 requests and indicates the number of bytes actually written to
-the sense buffer.
+the \field{sense} buffer.
 
-The residual field is only present for scsi packet command
+\field{residual} field is only present for scsi packet command
 requests and indicates the residual size, calculated as data
 length - number of bytes actually transferred.
 
-Historically, devices assumed that the fields type, ioprio and
-sector reside in a single, separate device-readable buffer; the fields
-errors, data_len, sense_len and residual reside in a single,
-separate device-writable buffer; the sense field in a separate
-device-writable buffer of size 96 bytes, by itself; the fields errors,
-data_len, sense_len and residual in a single device-writable buffer;
-and the status field is a separate device-writable buffer of size 1
+Historically, devices assumed that \field{type}, \field{ioprio} and
+\field{sector} reside in a single, separate device-readable buffer;
+\field{errors}, \field{data_len}, \field{sense_len} and residual reside in a single,
+separate device-writable buffer; \field{sense} in a separate
+device-writable buffer of size 96 bytes, by itself; \field{errors},
+\field{data_len}, \field{sense_len} and \field{residual} in a single device-writable buffer;
+and \field{status} is a separate device-writable buffer of size 1
 byte, by itself.
 
 
@@ -3258,11 +3255,11 @@ only exist if VIRTIO_CONSOLE_F_MULTIPORT is set.
 \subsection{Feature bits}\label{sec:Device Types / Console Device / Feature bits}
 
 \begin{description}
-\item[VIRTIO_CONSOLE_F_SIZE (0)] Configuration cols and rows fields
+\item[VIRTIO_CONSOLE_F_SIZE (0)] Configuration \field{cols} and \field{rows}
     are valid.
 
 \item[VIRTIO_CONSOLE_F_MULTIPORT (1)] Device has support for multiple
-    ports; configuration fields nr_ports and max_nr_ports are
+    ports; \field{nr_ports} and \field{max_nr_ports} are
     valid and control virtqueues will be used.
 
 \item[VIRTIO_CONSOLE_F_EMERG_WRITE (2)] Device has support for emergency write.
@@ -3298,19 +3295,19 @@ native endian of the guest rather than (necessarily) little-endian.
 \subsection{Device Initialization}\label{sec:Device Types / Console Device / Device Initialization}
 
 \begin{enumerate}
-\item If the VIRTIO_CONSOLE_F_EMERG_WRITE feature is offered, the
-  emerg_wr field of the configuration can be written at any time.
+\item If the VIRTIO_CONSOLE_F_EMERG_WRITE feature is offered,
+  \field{emerg_wr} field of the configuration can be written at any time.
   Thus it should work for very early boot debugging output as well as
   catastophic OS failures (eg. virtio ring corruption).
 
 \item If the VIRTIO_CONSOLE_F_SIZE feature is negotiated, the driver
-  can read the console dimensions from the configuration fields.
+  can read the console dimensions from \field{cols} and \field{rows}.
 
 \item If the VIRTIO_CONSOLE_F_MULTIPORT feature is negotiated, the
   driver can spawn multiple ports, not all of which may be
   attached to a console. Some could be generic ports. In this
-  case, the control virtqueues are enabled and according to the
-  max_nr_ports configuration-space value, the appropriate number
+  case, the control virtqueues are enabled and according to
+  \field{max_nr_ports}, the appropriate number
   of virtqueues are created. A control message indicating the
   driver is ready is sent to the device. The device can then send
   control messages for adding new ports to the device. After
@@ -3509,10 +3506,10 @@ The device is driven by the receipt of a
 configuration change interrupt.
 
 \begin{enumerate}
-\item The “num_pages” configuration field is examined. If this is
-  greater than the “actual” number of pages, memory must be given
-  to the balloon. If it is less than the “actual” number of
-  pages, memory may be taken back from the balloon for general
+\item \field{num_pages} configuration field is examined. If this is
+  greater than the \field{actual} number of pages, memory must be given
+  to the balloon. If it is less than \field{actual},
+  memory may be taken back from the balloon for general
   use.
 
 \item To supply memory to the balloon (aka. inflate):
@@ -3540,7 +3537,7 @@ configuration change interrupt.
   \end{enumerate}
 
 \item In either case, once the device has completed the inflation or
-  deflation, the “actual” field of the configuration should be
+  deflation, \field{actual} should be
   updated to reflect the new number of pages in the balloon.\footnote{As updates to configuration space are not atomic, this field
 isn't particularly reliable, but can be used to diagnose buggy guests.
 }
@@ -3664,8 +3661,8 @@ targets that receive and process the requests.
 
 \subsection{Device configuration layout}\label{sec:Device Types / SCSI Host Device / Device configuration layout}
 
-  All fields of this configuration are always available. sense_size
-  and cdb_size are writable by the driver.
+  All fields of this configuration are always available. \field{sense_size}
+  and \field{cdb_size} are writable by the driver.
 
 \begin{lstlisting}
 /* Note: LEGACY version was not little endian! */
@@ -3684,41 +3681,41 @@ struct virtio_scsi_config {
 \end{lstlisting}
 
 \begin{description}
-\item[num_queues] is the total number of request virtqueues exposed by
+\item[\field{num_queues}] is the total number of request virtqueues exposed by
     the device. The driver is free to use only one request queue,
     or it can use more to achieve better performance.
 
-\item[seg_max] is the maximum number of segments that can be in a
-    command. A bidirectional command can include seg_max input
-    segments and seg_max output segments.
+\item[\field{seg_max}] is the maximum number of segments that can be in a
+    command. A bidirectional command can include \field{seg_max} input
+    segments and \field{seg_max} output segments.
 
-\item[max_sectors] is a hint to the driver about the maximum transfer
+\item[\field{max_sectors}] is a hint to the driver about the maximum transfer
     size it should use.
 
-\item[cmd_per_lun] is a hint to the driver about the maximum number of
+\item[\field{cmd_per_lun}] is a hint to the driver about the maximum number of
     linked commands it should send to one LUN. The actual value
-    to be used is the minimum of cmd_per_lun and the virtqueue
+    to be used is the minimum of \field{cmd_per_lun} and the virtqueue
     size.
 
-\item[event_info_size] is the maximum size that the device will fill
+\item[\field{event_info_size}] is the maximum size that the device will fill
     for buffers that the driver places in the eventq. The driver
     should always put buffers at least of this size. It is
     written by the device depending on the set of negotated
     features.
 
-\item[sense_size] is the maximum size of the sense data that the
+\item[\field{sense_size}] is the maximum size of the sense data that the
     device will write. The default value is written by the device
     and will always be 96, but the driver can modify it. It is
     restored to the default when the device is reset.
 
-\item[cdb_size] is the maximum size of the CDB that the driver will
+\item[\field{cdb_size}] is the maximum size of the CDB that the driver will
     write. The default value is written by the device and will
     always be 32, but the driver can likewise modify it. It is
     restored to the default when the device is reset.
 
-\item[max_channel, max_target and max_lun] can be used by the driver
+\item[\field{max_channel}, \field{max_target} and \field{max_lun}] can be used by the driver
     as hints to constrain scanning the logical units on the
-    host.h
+    host.
 \end{description}
 
 \subsubsection{Legacy Interface: Device configuration layout}\label{sec:Device Types / SCSI Host Device / Device configuration layout / Legacy Interface: Device configuration layout}
@@ -3793,48 +3790,48 @@ struct virtio_scsi_req_cmd {
 #define VIRTIO_SCSI_S_ACA               3
 \end{lstlisting}
 
-The lun field addresses a target and logical unit in the
+\field{lun} addresses a target and logical unit in the
 virtio-scsi device's SCSI domain. The only supported format for
-the LUN field is: first byte set to 1, second byte set to target,
+the \field{lun} field is: first byte set to 1, second byte set to target,
 third and fourth byte representing a single level LUN structure,
 followed by four zero bytes. With this representation, a
 virtio-scsi device can serve up to 256 targets and 16384 LUNs per
 target.
 
-The id field is the command identifier (“tag”).
+\field{id} is the command identifier (“tag”).
 
-task_attr, prio and crn should be left to zero. task_attr defines
+\field{task_attr}, \field{prio} and \field{crn} should be left to zero. \field{task_attr} defines
 the task attribute as in the table above, but all task attributes
-may be mapped to SIMPLE by the device; crn may also be provided
+may be mapped to SIMPLE by the device; \field{crn} may also be provided
 by clients, but is generally expected to be 0. The maximum CRN
 value defined by the protocol is 255, since CRN is stored in an
 8-bit integer.
 
 All of these fields are defined in SAM. They are always
-device-readable, as are the cdb and dataout field. The cdb_size is
+device-readable, as are \field{cdb} and \field{dataout}. \field{cdb_size} is
 taken from the configuration space.
 
-sense and subsequent fields are always device-writable. The sense_len
-field indicates the number of bytes actually written to the sense
-buffer. The residual field indicates the residual size,
+\field{sense} and subsequent fields are always device-writable. \field{sense_len}
+indicates the number of bytes actually written to the sense
+buffer. \field{residual} indicates the residual size,
 calculated as “data_length - number_of_transferred_bytes”, for
 read or write operations. For bidirectional commands, the
 number_of_transferred_bytes includes both read and written bytes.
-A residual field that is less than the size of datain means that
-the dataout field was processed entirely. A residual field that
-exceeds the size of datain means that the dataout field was
-processed partially and the datain field was not processed at
+A \field{residual} that is less than the size of \field{datain} means that
+the dataout field was processed entirely. A \field{residual} that
+exceeds the size of \field{datain} means that \field{dataout} was
+processed partially and \field{datain} was not processed at
 all.
 
-The status byte is written by the device to be the status code as
+The \field{status} byte is written by the device to be the status code as
 defined in SAM.
 
-The response byte is written by the device to be one of the
+The \field{response} byte is written by the device to be one of the
 following:
 
 \begin{description}
 
-\item[VIRTIO_SCSI_S_OK] when the request was completed and the status
+\item[VIRTIO_SCSI_S_OK] when the request was completed and the \field{status}
   byte is filled with a SCSI status code (not necessarily
   "GOOD").
 
@@ -3845,7 +3842,7 @@ following:
   ABORT TASK or ABORT TASK SET task management function.
 
 \item[VIRTIO_SCSI_S_BAD_TARGET] if the request was never processed
-  because the target indicated by the lun field does not exist.
+  because the target indicated by \field{lun} does not exist.
 
 \item[VIRTIO_SCSI_S_RESET] if the request was cancelled due to a bus
   or device reset (including a task management function).
@@ -3864,7 +3861,7 @@ following:
   same path should work.
 
 \item[VIRTIO_SCSI_S_FAILURE] for other host or driver error. In
-  particular, if neither dataout nor datain is empty, and the
+  particular, if neither \field{dataout} nor \field{datain} is empty, and the
   VIRTIO_SCSI_F_INOUT feature has not been negotiated, the
   request will be immediately returned with a response equal to
   VIRTIO_SCSI_S_FAILURE.
@@ -3897,11 +3894,12 @@ struct virtio_scsi_ctrl {
 #define VIRTIO_SCSI_S_INCORRECT_LUN            12
 \end{lstlisting}
 
-The type identifies the remaining fields.
+The \field{type} identifies the remaining fields.
 
 The following commands are defined:
 
-  Task management function
+\begin{itemize}
+\item Task management function.
 \begin{lstlisting}
 #define VIRTIO_SCSI_T_TMF                      0
 
@@ -3932,24 +3930,23 @@ struct virtio_scsi_ctrl_tmf
 #define VIRTIO_SCSI_S_FUNCTION_REJECTED        11
 \end{lstlisting}
 
-  The type is VIRTIO_SCSI_T_TMF; the subtype field defines. All
-  fields except response are filled by the driver. The subtype
-  field must always be specified and identifies the requested
+  The \field{type} is VIRTIO_SCSI_T_TMF; \field{subtype} defines. All
+  fields except \field{response} are filled by the driver. \field{subtype}
+  must always be specified and identifies the requested
   task management function.
 
   Other fields may be irrelevant for the requested TMF; if so,
-  they are ignored but they should still be present. The lun
+  they are ignored but they should still be present. \field{lun}
   field is in the same format specified for request queues; the
   single level LUN is ignored when the task management function
-  addresses a whole I_T nexus. When relevant, the value of the id
-  field is matched against the id values passed on the requestq.
+  addresses a whole I_T nexus. When relevant, the value of \field{id}
+  is matched against the id values passed on the requestq.
 
   The outcome of the task management function is written by the
-  device in the response field. The command-specific response
+  device in \field{response}. The command-specific response
   values map 1-to-1 with those defined in SAM.
 
-  Asynchronous notification query
-
+\item Asynchronous notification query.
 \begin{lstlisting}
 #define VIRTIO_SCSI_T_AN_QUERY                    1
 
@@ -3974,17 +3971,17 @@ struct virtio_scsi_ctrl_an {
   By sending this command, the driver asks the device which
   events the given LUN can report, as described in paragraphs 6.6
   and A.6 of the SCSI MMC specification. The driver writes the
-  events it is interested in into the event_requested; the device
+  events it is interested in into \field{event_requested}; the device
   responds by writing the events that it supports into
-  event_actual.
+  \field{event_actual}.
 
-  The type is VIRTIO_SCSI_T_AN_QUERY. The lun and event_requested
-  fields are written by the driver. The event_actual and response
+  The \field{type} is VIRTIO_SCSI_T_AN_QUERY. \field{lun} and \field{event_requested}
+  are written by the driver. \field{event_actual} and \field{response}
   fields are written by the device.
 
-  No command-specific values are defined for the response byte.
+  No command-specific values are defined for the \field{response} byte.
 
-  Asynchronous notification subscription
+\item Asynchronous notification subscription.
 \begin{lstlisting}
 #define VIRTIO_SCSI_T_AN_SUBSCRIBE                2
 
@@ -4002,17 +3999,18 @@ struct virtio_scsi_ctrl_an {
   By sending this command, the driver asks the specified LUN to
   report events for its physical interface, again as described in
   the SCSI MMC specification. The driver writes the events it is
-  interested in into the event_requested; the device responds by
-  writing the events that it supports into event_actual.
+  interested in into \field{event_requested}; the device responds by
+  writing the events that it supports into \field{event_actual}.
 
   Event types are the same as for the asynchronous notification
   query message.
 
-  The type is VIRTIO_SCSI_T_AN_SUBSCRIBE. The lun and
-  event_requested fields are written by the driver. The
-  event_actual and response fields are written by the device.
+  The \field{type} is VIRTIO_SCSI_T_AN_SUBSCRIBE. \field{lun} and
+  \field{event_requested} are written by the driver.
+  \field{event_actual} and \field{response} are written by the device.
 
   No command-specific values are defined for the response byte.
+\end{itemize}
 
 \paragraph{Legacy Interface: Device Operation: controlq}\label{sec:Device Types / SCSI Host Device / Device Operation / Device Operation: controlq / Legacy Interface: Device Operation: controlq}
 
@@ -4055,16 +4053,17 @@ struct virtio_scsi_event {
 }
 \end{lstlisting}
 
-If bit 31 is set in the event field, the device failed to report
+If bit 31 is set in \field{event}, the device failed to report
 an event due to missing buffers. In this case, the driver should
 poll the logical units for unit attention conditions, and/or do
 whatever form of bus scan is appropriate for the guest operating
 system.
 
-The meaning of the reason field depends on the
-contents of the event field. The following events are defined:
+The meaning of \field{reason} depends on the
+contents of \field{event}. The following events are defined:
 
-  No event
+\begin{itemize}
+\item No event.
 \begin{lstlisting}
 #define VIRTIO_SCSI_T_NO_EVENT         0
 \end{lstlisting}
@@ -4085,7 +4084,7 @@ contents of the event field. The following events are defined:
     flag.
 \end{itemize}
 
-  Transport reset
+\item Transport reset
 \begin{lstlisting}
 #define VIRTIO_SCSI_T_TRANSPORT_RESET  1
 
@@ -4097,24 +4096,24 @@ contents of the event field. The following events are defined:
   By sending this event, the device signals that a logical unit
   on a target has been reset, including the case of a new device
   appearing or disappearing on the bus.The device fills in all
-  fields. The event field is set to
-  VIRTIO_SCSI_T_TRANSPORT_RESET. The lun field addresses a
+  fields. \field{event} is set to
+  VIRTIO_SCSI_T_TRANSPORT_RESET. \field{lun} addresses a
   logical unit in the SCSI host.
 
-  The reason value is one of the three \#define values appearing
+  The \field{reason} value is one of the three \#define values appearing
   above:
 
-  \begin{itemize}
-  \item VIRTIO_SCSI_EVT_RESET_REMOVED (“LUN/target removed”) is used
+  \begin{description}
+  \item[VIRTIO_SCSI_EVT_RESET_REMOVED] (“LUN/target removed”) is used
     if the target or logical unit is no longer able to receive
     commands.
 
-  \item VIRTIO_SCSI_EVT_RESET_HARD (“LUN hard reset”) is used if the
+  \item[VIRTIO_SCSI_EVT_RESET_HARD] (“LUN hard reset”) is used if the
     logical unit has been reset, but is still present.
 
-  \item VIRTIO_SCSI_EVT_RESET_RESCAN (“rescan LUN/target”) is used if
+  \item[VIRTIO_SCSI_EVT_RESET_RESCAN] (“rescan LUN/target”) is used if
     a target or logical unit has just appeared on the device.
-  \end{itemize}
+  \end{description}
 
   The “removed” and “rescan” events, when sent for LUN 0, may
   apply to the entire target. After receiving them the driver
@@ -4149,7 +4148,7 @@ contents of the event field. The following events are defined:
   codes, and it will process them as if it the driver had
   received the equivalent event.
 
-  Asynchronous notification
+  \item Asynchronous notification
 \begin{lstlisting}
 #define VIRTIO_SCSI_T_ASYNC_NOTIFY     2
 \end{lstlisting}
@@ -4166,7 +4165,7 @@ contents of the event field. The following events are defined:
   When dropped events are reported, the driver should poll for
   asynchronous events manually using SCSI commands.
 
-  LUN parameter change
+  \item LUN parameter change
 \begin{lstlisting}
 #define VIRTIO_SCSI_T_PARAM_CHANGE  3
 \end{lstlisting}
@@ -4186,6 +4185,7 @@ contents of the event field. The following events are defined:
   event and the asynchronous notification event.
   For simplicity, as of this version of the specification the host must
   never report this event for MMC devices.
+\end{itemize}
 
 \paragraph{Legacy Interface: Device Operation: eventq}\label{sec:Device Types / SCSI Host Device / Device Operation / Device Operation: eventq / Legacy Interface: Device Operation: eventq}
 For legacy devices, the fields in struct virtio_scsi_event are the
@@ -4200,16 +4200,16 @@ Currently there are four device-independent feature bits defined:
   that the driver can use descriptors with the VRING_DESC_F_INDIRECT
   flag set, as described in \ref{sec:Basic Facilities of a Virtio Device / Virtqueues / The Virtqueue Descriptor Table / Indirect Descriptors}~\nameref{sec:Basic Facilities of a Virtio Device / Virtqueues / The Virtqueue Descriptor Table / Indirect Descriptors}.
 
-  \item[VIRTIO_F_RING_EVENT_IDX(29)] This feature enables the used_event
-  and the avail_event fields. If set, it indicates that the
-  device should ignore the flags field in the available ring
-  structure. Instead, the used_event field in this structure is
+  \item[VIRTIO_F_RING_EVENT_IDX(29)] This feature enables the \field{used_event}
+  and the \field{avail_event} fields. If set, it indicates that the
+  device should ignore \field{flags} in the available ring
+  structure. Instead, \field{used_event} in this structure is
   used by driver to suppress device interrupts. Further, the
-  driver should ignore the flags field in the used ring
-  structure. Instead, the avail_event field in this structure is
+  driver should ignore the \field{flags} field in the used ring
+  structure. Instead, \field{avail_event} in this structure is
   used by the device to suppress notifications. If unset, the
-  driver should ignore the used_event field; the device should
-  ignore the avail_event field; the flags field is used
+  driver should ignore \field{used_event}; the device should
+  ignore \field{avail_event} and the \field{flags} fields should be used,
 
   \item[VIRTIO_F_VERSION_1(32)] This feature must be offered by any device
   compliant with this specification, and acknowledged by all device
@@ -4229,7 +4229,7 @@ Legacy or transitional devices may offer the following:
   indicates that the driver wants an interrupt if the device runs
   out of available descriptors on a virtqueue, even though
   interrupts are suppressed using the VRING_AVAIL_F_NO_INTERRUPT
-  flag or the used_event field. An example of this is the
+  flag or the \field{used_event} field. An example of this is the
   networking driver: it doesn't need to know every time a packet
   is transmitted, but it does need to free the transmitted
   packets a finite time after they are transmitted. It can avoid
